'use strict';

var ClassFactory = require('classing').Factory,
    Casting = require('casting'),
    Validating = require('validating'),
    each = ClassFactory.each,
    createAccessor = ClassFactory.createAccessor;

module.exports = ClassFactory.extend({
  /**
   * Create a constructor function for a class.
   *
   * @param  {String} name The name of the class.
   *
   * @return {Function} The constructor function.
   */
  createConstructor: function (name) {
    var body = 'return function ' + name + ' (config) {\n\
                  "use strict";\n\
                  if (!(this instanceof ' + name + ')) {\n\
                    return new ' + name + '(config);\n\
                  }\n\
                  this.applyDefaults();\n\
                  if (config) { this.configure(config); }\n\
                  this.initialize();\n\
                };';
    return (new Function(body))(); // jshint ignore: line
  },
  /**
   * Create the default static methods / properties for a class.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   *
   * @return {Object} The default static descriptors.
   */
  createDefaultStatic: function (Class, descriptors, staticDescriptors) {
    var context = ClassFactory.prototype.createDefaultStatic.call(this, Class, descriptors, staticDescriptors);
    context.cast = {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.createStaticCast(Class, descriptors, staticDescriptors)
    };
    context.validate = {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.createStaticValidate(Class, descriptors, staticDescriptors)
    };
    context.input = {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.createStaticInput(Class, descriptors, staticDescriptors)
    };
    context.toJSON = {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.createStaticToJSON(Class, descriptors, staticDescriptors)
    };
    return context;
  },
  /**
   * Create a function which can cast objects to this class.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   *
   * @return {Function} The generated function.
   */
  createStaticCast: function (Class, descriptors, staticDescriptors) {
    var castAll = Casting.forDescriptors(descriptors);
    function cast (value) {
      if (!(value instanceof this)) {
       return new this(castAll(value));
      }
      else {
        return castAll(value);
      }
    }

    cast.isAutoGenerated = true;
    return cast;
  },
  /**
   * Create a function which can validate instances of the class.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   *
   * @return {Function} The generated function.
   */
  createStaticValidate: function (Class, descriptors, staticDescriptors) {
    var validate = Validating.forDescriptors(descriptors);
    validate.isAutoGenerated = true;
    return validate;
  },
  /**
   * Create a function which can accept user input for the model.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   *
   * @return {Function} The generated function.
   */
  createStaticInput: function (Class, descriptors, staticDescriptors) {
    var casters = {},
        validators = {},
        body = '"use strict";\n\
                var valid = true,\n\
                    errors = {},\n\
                    result;\n\
                if (values === undefined) {\n\
                  values = subject || {};\n\
                  subject = new this();\n\
                }\n';

    each(descriptors, function (descriptor, key) {
      if (key === '[[state]]' ||
          key === 'initialize' ||
          (!descriptor.writable && typeof descriptor.set !== 'function') ||
          typeof descriptor.value === 'function'
      ) {
        return;
      }

      var accessor = createAccessor(key);
      body += 'if (values'+accessor+' !== undefined) {\n';
      if (descriptor.type) {
        casters[key] = Casting.get(descriptor.type);
        body += 'if (values'+accessor+' === null) {\n\
                   subject'+accessor+' = null;\n\
                 }\n\
                 else {\n\
                  result = tryCatch(casters'+accessor+', values'+accessor+');\n\
                  if (result.error) {\n\
                    valid = false;\n\
                    errors'+accessor+' = result.error.message;\n\
                  }\n\
                  else {\n\
                    subject'+accessor+' = result.value;\n\
                  }\n\
                }\n';
      }
      else {
        body += 'subject'+accessor+' = values'+accessor+';\n';
      }
      body += '}\n';
      if (descriptor.rules) {
        validators[key] = Validating.forDescriptor(key, descriptor);
        body += 'if (!errors'+accessor+') {\n\
                  result = validators'+accessor+'(subject'+accessor+');\n\
                  if (!result.valid) {\n\
                    valid = false;\n\
                    errors'+accessor+' = result.error;\n\
                  }\n\
                }\n';
      }
    });

    body += 'return {\n\
              valid: valid,\n\
              value: subject,\n\
              errors: errors\n\
            };';

    var input = this.createDynamicFunction('validators', 'casters', 'tryCatch', 'subject', 'values', body);

    var fn = function (subject, values) {
      return input.call(this, validators, casters, tryCatch1, subject, values);
    };
    fn.isAutoGenerated = true;
    return fn;
  },
  /**
   * Create a `configure` function for a class.
   *
   * @param  {Function} Class       The class.
   * @param  {Object}   descriptors The property descriptors.
   *
   * @return {Function} The configure function.
   */
  createConfigure: function (Class, descriptors) {
    var body = '"use strict";\n';
    var casters = {};
    each(descriptors, function (descriptor, name) {
      if (descriptor.writable || typeof descriptor.set === 'function') {
        var accessor = createAccessor(name);
        if (descriptor.cast || descriptor.type) {
          casters[name] = Casting.forDescriptor(descriptor);
          body += 'if (config' + accessor + ' !== undefined) {\n\
                      this' + accessor + ' = casters' + accessor + '(config' + accessor + ');\n\
                   }\n';
        }
        else {
          body += 'if (config' + accessor + ' !== undefined) {\n\
                      this' + accessor + ' = config' + accessor + ';\n\
                   }\n';
        }
      }
    });
    var configure = this.createDynamicFunction('casters', 'config', body);
    var fn = function (config) {
      return configure.call(this, casters, config);
    };
    fn.isAutoGenerated = true;
    return fn;
  },
  /**
   * Create a function which can return a representation
   * of the **class**, which can be encoded as JSON.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   *
   * @return {Function} The generated function.
   */
  createStaticToJSON: function (Class, descriptors, staticDescriptors) {
    var properties = {};
    each(descriptors, function (descriptor, name) {
      var property = {};
      properties[name] = property;
      each(descriptor, function (value, key) {
        if (key === 'rules') {
          property.rules = value.map(function (item) {
            var name;
            if (Array.isArray(item)) {
              name = item[0];
              item = item[1] || {};
              item.name = name;
              return item;
            }
            else {
              return item;
            }
          });
        }
        else if (!isBuiltinDescriptorKey(key)) {
          property[key] = value;
        }
      });
    });
    var toJSON = function () {
      return {
        '@context': this['@context'],
        '@id': this['@id'],
        '@type': this['@type'],
        name: this.name,
        properties: properties
      };
    };

    toJSON.isAutoGenerated = true;
    return toJSON;
  },
  /**
   * Update the dynamic auto-generated functions for a class.
   *
   * @param  {Function} Class             The class.
   * @param  {Object}   descriptors       The property descriptors.
   * @param  {Object}   staticDescriptors The static property descriptors.
   */
  updateDynamicFunctions: function (Class, descriptors) {
    ClassFactory.prototype.updateDynamicFunctions.call(this, Class, descriptors);
    if (!Class.cast || Class.cast.isAutoGenerated) {
      Class.cast = this.createStaticCast(Class, descriptors);
    }
    if (!Class.validate || Class.validate.isAutoGenerated) {
      Class.validate = this.createStaticValidate(Class, descriptors);
    }
    if (!Class.input || Class.input.isAutoGenerated) {
      Class.input = this.createStaticInput(Class, descriptors);
    }
    if (!Class.toJSON || Class.toJSON.isAutoGenerated) {
      Class.toJSON = this.createStaticToJSON(Class, descriptors);
    }
  }
});

// try..catch causes deoptimisation in V8 and most
// other JS engines. Using a specialist function minimises the impact.

function tryCatch1 (fn, arg1) {
  var errorObject = {};
  try {
    errorObject.value = fn(arg1);
  }
  catch (e) {
    errorObject.error = e;
  }
  return errorObject;
}

function isBuiltinDescriptorKey (key) {
  switch (key) {
    case 'enumerable':
    case 'configurable':
    case 'writable':
    case 'get':
    case 'set':
    case 'value':
      return true;
    default:
      return false;
  }
}