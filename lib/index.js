"use strict";

var Classing = require('classing'),
    Casting = require('casting'),
    Validating = require('validating');


var Modeling = Classing.extend({
  /**
   * Make a constructor for a class.
   *
   * @param  {String} name The name of the class.
   * @return {Function}    The constructor function.
   */
  makeConstructor: function (name) {
    var body = 'return function ' + name + ' (config) {' +
               '  if (!(this instanceof ' + name + ')) {' +
               '    return new ' + name + '(config);' +
               '  }' +
               '  Object.defineProperty(this, "__state__", {value: {}});' +
               '  this.applyDefaults();' +
               '  if (config) { this.configure(config); }' +
               '  this.initialize();' +
               '};';
    return new Function(body)(); // jshint ignore:line
  },

  /**
   * Make a prototype for a class, based on the given descriptors.
   *
   * @param  {Function} Class       The class itself.
   * @param  {Object} descriptors   The descriptors for the class.
   */
  makePrototype: function (Class, descriptors) {
    Classing.makePrototype.call(this, Class, descriptors);
    Object.defineProperties(Class.prototype, {
      __state__: {
        enumerable: false,
        writable: true
      }
    });
  },


  /**
   * Make the static methods for a class.
   *
   * @param  {Function} Class        The class itself.
   * @param  {Object}   descriptors  The property descriptors for the class.
   */
  makeStatic: {
    value: function (Class, descriptors) {
      var Modeling = this; // to allow subclassing
      Classing.makeStatic.call(this, Class, descriptors);
      var defineProperty = Class.defineProperty;
      Object.defineProperties(Class, {
        /**
         * Define a new property on the class.
         */
        defineProperty: {
          configurable: true,
          value: function (name, descriptor, skipReload) {
            var cast;
            if (name !== '__state__' &&
                descriptor &&
                descriptor.type &&
               !descriptor.hasOwnProperty('get') &&
               !descriptor.hasOwnProperty('set') &&
               !descriptor.hasOwnProperty('value')
            ) {
              cast = Casting.get(descriptor.type);
              descriptor.enumerable = true;
              descriptor.configurable = true;
              descriptor.get = function () {
                return this.__state__[name];
              };
              descriptor.set = function (value) {
                this.__state__[name] = cast(value);
              };
            }
            return defineProperty.call(this, name, descriptor, skipReload);
          }
        },
        /**
         * Update any autogenerated functions.
         */
        updateAutoGeneratedFunctions: {
          configurable: true,
          value: function () {

            if (!this.prototype.applyDefaults || this.prototype.applyDefaults.isAutoGenerated) {
              this.prototype.applyDefaults = this.makeApplyDefaults(descriptors);
            }
            if (!this.prototype.configure || this.prototype.configure.isAutoGenerated) {
              this.prototype.configure = this.makeConfigure(descriptors);
            }
            if (!this.prototype.toJSON || this.prototype.toJSON.isAutoGenerated) {
              this.prototype.toJSON = this.makeToJSON(descriptors);
            }
            if (!this.prototype.forEach || this.prototype.forEach.isAutoGenerated) {
              this.prototype.forEach = this.makeForEach(descriptors);

            }
            if (!this.prototype.keys || this.prototype.keys.isAutoGenerated) {
              this.prototype.keys = this.makeKeys(descriptors);
            }
            if (!this.cast || this.cast.isAutoGenerated) {
              this.cast = this.makeCast(descriptors);
            }
            if (!this.input || this.input.isAutoGenerated) {
              this.input = this.makeInput(descriptors);
            }
            if (!this.validate || this.validate.isAutoGenerated) {
              this.validate = this.makeValidate(descriptors);
            }
            if (!this.toJSON || this.toJSON.isAutoGenerated) {
              this.toJSON = this.makeStaticToJSON(descriptors);
            }
          }
        },
        /**
         * Make a function which can cast property values to the correct type.
         * @type {Function}
         */
        makeCast: {
          configurable: true,
          value: function (descriptors) {
            var castAll = Casting.forDescriptors(descriptors),
                fn = function (value) {
                  if (!(value instanceof this)) {
                   return new this(value);
                  }
                  else {
                    return castAll(value);
                  }
                };

            fn.isAutoGenerated = true;
            return fn;
          }
        },
        /**
         * Make a function which can validate instances of the class.
         * @type {Function}
         */
        makeValidate: {
          configurable: true,
          value: function (descriptors) {
            var validate = Validating.forDescriptors(descriptors);
            validate.isAutoGenerated = true;
            return validate;
          }
        },
        /**
         * Make a function which can accept user input for the model.
         * @type {Function}
         */
        makeInput: {
          configurable: true,
          value: function (descriptors) {
            var keys = Object.keys(descriptors),
                total = keys.length,
                casters = {},
                validators = {},
                body = '"use strict";\n',
                accessor, key, descriptor, i;

            body += 'var valid = true, errors = {}, result;\n' +
                    'if (values === undefined) { values = subject || {}; subject = new this(); }\n';
            for (i = 0; i < total; i++) {
              key = keys[i];
              descriptor = descriptors[key];

              if (key === '__state__' ||
                  key === 'initialize' ||
                  (!descriptor.writable && !descriptor.hasOwnProperty('set'))
              ) {
                continue;
              }

              if (/^([\w|_|$]+)$/.test(key)) {
                accessor = '.' + key;
              }
              else {
                accessor = '["' + key + '"]';
              }

              body += 'if (values' + accessor + ' !== undefined) {\n';
              if (descriptor.type) {
                casters[key] = Casting.get(descriptor.type);
                body += '  if (values' + accessor + ' === null) {\n';
                body += '     values' + accessor + ' = null;\n';
                body += '  }\n';
                body += '  else {\n';
                body += '    result = tryCatch1(casters' + accessor + ', values' + accessor +');\n';
                body += '    if (result.error) {\n';
                body += '       valid = false;\n';
                body += '       errors' + accessor + ' = result.error.message;\n';
                body += '    }\n';
                body += '    else {\n';
                body += '      subject' + accessor + ' = result.value;\n';
                body += '    }\n';
                body += '  }\n';
              }
              else {
                body += '  subject' + accessor + ' = values' + accessor + ';\n';
              }
              body += '}\n';
              if (descriptor.rules) {
                validators[key] = Validating.forDescriptor(key, descriptor);
                body += 'if (!errors' + accessor + ') {\n';
                body += '  result = validators' + accessor + '(subject' + accessor + ');\n';
                body += '  if (!result.valid) {\n';
                body += '    valid = false;\n';
                body += '    errors' + accessor + ' = result.error;\n';
                body += '  }\n';
                body += '}\n';
              }
            }

            body += 'return {valid: valid, value: subject, errors: errors};';

            var fn = new Function('validators', 'casters', 'tryCatch1', 'subject', 'values', body); // jshint ignore: line
            fn = fn.bind(this, validators, casters, tryCatch1);
            fn.isAutoGenerated = true;
            return fn;
          }
        },
        /**
         * Make an efficient `configure()` function to set property values
         * for an object based on the given descriptors.
         *
         * @param  {Object} descriptors The descriptors for the object.
         * @return {Function}           The `configure()` function.
         */
        makeConfigure: {
          configurable: true,
          value: function (descriptors) {
            var keys = Object.keys(descriptors),
                total = keys.length,
                casters = {},
                body = '',
                accessor, key, descriptor, i;

            for (i = 0; i < total; i++) {
              key = keys[i];
              if (key === '__state__') {
                continue;
              }
              descriptor = descriptors[key];
              if (descriptor.writable || descriptor.hasOwnProperty('set')) {
                if (/^([\w|_|$]+)$/.test(key)) {
                  accessor = '.' + key;
                }
                else {
                  accessor = '["' + key + '"]';
                }
                body += 'if (config' + accessor + ' !== undefined) {\n';
                body += '  this' + accessor + ' = config' + accessor + ';\n';
                body += '}';
              }
            }

            var fn = new Function('casters', 'config', body); // jshint ignore:line
            var configure = function (config) {
              return fn.call(this, casters, config);
            };
            configure.isAutoGenerated = true;
            return configure;
          }
        },
        /**
         * Make an efficient `forEach()` function for the given descriptors.
         * @type {Function}
         */
        makeForEach: {
          configurable: true,
          value: function (descriptors) {
            var keys = Object.keys(descriptors),
                total = keys.length,
                body = 'thisContext = thisContext || this;\n',
                accessor, key, descriptor, i;

            for (i = 0; i < total; i++) {
              key = keys[i];
              descriptor = descriptors[key];
              if (!descriptor.enumerable) {
                continue;
              }
              if (/^([\w|_|$]+)$/.test(key)) {
                accessor = '.' + key;
              }
              else {
                accessor = '["' + key + '"]';
              }
              body += 'if (this' + accessor + ' !== undefined) { fn.call(thisContext, this' + accessor + ', "' + key + '", this); }\n'; // jshint ignore:line
            }
            var forEach = new Function('fn', 'thisContext', body); // jshint ignore: line
            forEach.isAutoGenerated = true;
            return forEach;
          }
        },
        /**
         * Make an efficient `keys()` function for the given descriptors.
         * @type {Function}
         */
        makeKeys: {
          configurable: true,
          value: function (descriptors) {
            var names = Object.keys(descriptors).sort(),
                total = names.length,
                items = [],
                name, descriptor, i;

            for (i = 0; i < total; i++) {
              name = names[i];
              descriptor = descriptors[name];
              if (descriptor.enumerable) {
                items.push(name);
              }
            }
            var keys = function () { return items; };
            keys.isAutoGenerated = true;
            return keys;
          }
        },
        /**
         * Make a function which can return a representation of the **class**, which
         * can be encoded as JSON.
         *
         * @type {Function}
         */
        makeStaticToJSON: {
          configurable: true,
          value: function (descriptors) {
            var names = Object.keys(descriptors).sort(),
                totalNames = names.length,
                properties = {},
                property, name, descriptor, i,
                keys, totalKeys, key, j;

            for (i = 0; i < totalNames; i++) {
              name = names[i];
              descriptor = descriptors[name];
              if (descriptor.enumerable) {
                keys = Object.keys(descriptor);
                totalKeys = keys.length;
                property = {};
                properties[name] = property;
                for (j = 0; j < totalKeys; j++) {
                  key = keys[j];
                  switch (key) {
                    case 'enumerable':
                    case 'configurable':
                    case 'writable':
                    case 'get':
                    case 'set':
                    case 'value':
                      break;
                    case 'default':
                      if (typeof descriptor.default !== 'function') {
                        property.default = descriptor.default;
                      }
                      break;
                    case 'rules':
                      property.rules = descriptor.rules.map(function (item) {
                        var name;
                        if (Array.isArray(item)) {
                          name = item[0];
                          item = item[1] || {};
                          item.name = name;
                          return item;
                        }
                        else {
                          return item;
                        }
                      });
                      break;
                    default:
                      property[key] = descriptor[key];
                  }
                }
              }
            }
            var toJSON = function () {
              return {
                '@context': this['@context'],
                '@id': this['@id'],
                '@type': this['@type'] || this.name,
                name: this.name,
                properties: properties
              };
            };

            toJSON.isAutoGenerated = true;
            return toJSON;
          }
        }
      });
    }
  }
});

module.exports = Modeling;


// try..catch causes deoptimisation in v8.
// using a specialist function minimises the impact.

function tryCatch1 (fn, arg1) {
  var errorObject = {};
  try {
    errorObject.value = fn(arg1);
  }
  catch (e) {
    errorObject.error = e;
  }
  return errorObject;
}