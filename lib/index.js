"use strict";

var Classing = require('classing'),
    Casting = require('casting'),
    Validating = require('validating');


var Modeling = Classing.extend({
  /**
   * Make a constructor for a class.
   *
   * @param  {String} name The name of the class.
   * @return {Function}    The constructor function.
   */
  makeConstructor: function (name) {
    var body = 'return function ' + name + ' (config) {' +
               '  if (!(this instanceof ' + name + ')) {' +
               '    return new ' + name + '(config);' +
               '  }' +
               '  Object.defineProperty(this, "__state__", {value: {}});' +
               '  this.applyDefaults();' +
               '  if (config) { this.configure(config); }' +
               '  this.initialize();' +
               '};';
    return new Function(body)(); // jshint ignore:line
  },

  /**
   * Make a prototype for a class, based on the given descriptors.
   *
   * @param  {Function} Class       The class itself.
   * @param  {Object} descriptors   The descriptors for the class.
   */
  makePrototype: function (Class, descriptors) {
    Classing.makePrototype.call(this, Class, descriptors);
    Object.defineProperties(Class.prototype, {
      __state__: {
        enumerable: false,
        writable: true
      }
    });
  },


  /**
   * Make the static methods for a class.
   *
   * @param  {Function} Class        The class itself.
   * @param  {Object}   descriptors  The property descriptors for the class.
   */
  makeStatic: {
    value: function (Class, descriptors) {
      var Modeling = this; // to allow subclassing
      Classing.makeStatic.call(this, Class, descriptors);
      var defineProperty = Class.defineProperty;
      Object.defineProperties(Class, {
        /**
         * Define a new property on the class.
         */
        defineProperty: {
          configurable: true,
          value: function (name, descriptor, skipReload) {
            var cast;
            if (name !== '__state__' &&
                descriptor &&
                descriptor.type &&
               !descriptor.hasOwnProperty('get') &&
               !descriptor.hasOwnProperty('set') &&
               !descriptor.hasOwnProperty('value')
            ) {
              cast = Casting.get(descriptor.type);
              descriptor.enumerable = true;
              descriptor.configurable = true;
              descriptor.get = function () {
                return this.__state__[name];
              };
              descriptor.set = function (value) {
                this.__state__[name] = cast(value);
              };
            }
            return defineProperty.call(this, name, descriptor, skipReload);
          }
        },
        /**
         * Update any autogenerated functions.
         */
        updateAutoGeneratedFunctions: {
          configurable: true,
          value: function () {

            if (!this.prototype.applyDefaults || this.prototype.applyDefaults.isAutoGenerated) {
              this.prototype.applyDefaults = this.makeApplyDefaults(descriptors);
            }
            if (!this.prototype.configure || this.prototype.configure.isAutoGenerated) {
              this.prototype.configure = this.makeConfigure(descriptors);
            }
            if (!this.prototype.toJSON || this.prototype.toJSON.isAutoGenerated) {
              this.prototype.toJSON = this.makeToJSON(descriptors);
            }
            if (!this.prototype.forEach || this.prototype.forEach.isAutoGenerated) {
              this.prototype.forEach = this.makeForEach(descriptors);

            }
            if (!this.prototype.keys || this.prototype.keys.isAutoGenerated) {
              this.prototype.keys = this.makeKeys(descriptors);
            }
            if (!this.cast || this.cast.isAutoGenerated) {
              this.cast = this.makeCast(descriptors);
            }
            if (!this.validate || this.validate.isAutoGenerated) {
              this.validate = this.makeValidate(descriptors);
            }
            if (!this.toJSON || this.toJSON.isAutoGenerated) {
              this.toJSON = this.makeStaticToJSON(descriptors);
            }
          }
        },
        /**
         * Make a function which can cast property values to the correct type.
         * @type {Function}
         */
        makeCast: {
          configurable: true,
          value: function (descriptors) {
            var castAll = Casting.forDescriptors(descriptors),
                fn = function (value) {
                  if (!(value instanceof this)) {
                   return new this(value);
                  }
                  else {
                    return castAll(value);
                  }
                };

            fn.isAutoGenerated = true;
            return fn;
          }
        },
        /**
         * Make a function which can validate instances of the class.
         * @type {Function}
         */
        makeValidate: {
          configurable: true,
          value: function (descriptors) {
            var validate = Validating.forDescriptors(descriptors);
            validate.isAutoGenerated = true;
            return validate;
          }
        },
        /**
         * Make an efficient `configure()` function to set property values
         * for an object based on the given descriptors.
         *
         * @param  {Object} descriptors The descriptors for the object.
         * @return {Function}           The `configure()` function.
         */
        makeConfigure: {
          configurable: true,
          value: function (descriptors) {
            var keys = Object.keys(descriptors),
                total = keys.length,
                casters = {},
                body = '',
                accessor, key, descriptor, i;

            for (i = 0; i < total; i++) {
              key = keys[i];
              if (key === '__state__') {
                continue;
              }
              descriptor = descriptors[key];
              if (descriptor.writable || descriptor.hasOwnProperty('set')) {
                if (/^([\w|_|$]+)$/.test(key)) {
                  accessor = '.' + key;
                }
                else {
                  accessor = '["' + key + '"]';
                }
                body += 'if (config' + accessor + ' !== undefined) {\n';
                body += '  this' + accessor + ' = config' + accessor + ';\n';
                body += '}';
              }
            }

            var fn = new Function('casters', 'config', body); // jshint ignore:line
            var configure = function (config) {
              return fn.call(this, casters, config);
            };
            configure.isAutoGenerated = true;
            return configure;
          }
        },
        /**
         * Make an efficient `forEach()` function for the given descriptors.
         * @type {Function}
         */
        makeForEach: {
          configurable: true,
          value: function (descriptors) {
            var keys = Object.keys(descriptors),
                total = keys.length,
                body = 'thisContext = thisContext || this;\n',
                accessor, key, descriptor, i;

            for (i = 0; i < total; i++) {
              key = keys[i];
              descriptor = descriptors[key];
              if (!descriptor.enumerable) {
                continue;
              }
              if (/^([\w|_|$]+)$/.test(key)) {
                accessor = '.' + key;
              }
              else {
                accessor = '["' + key + '"]';
              }
              body += 'if (this' + accessor + ' !== undefined) { fn.call(thisContext, this' + accessor + ', "' + key + '", this); }\n'; // jshint ignore:line
            }
            var forEach = new Function('fn', 'thisContext', body); // jshint ignore: line
            forEach.isAutoGenerated = true;
            return forEach;
          }
        },
        /**
         * Make an efficient `keys()` function for the given descriptors.
         * @type {Function}
         */
        makeKeys: {
          configurable: true,
          value: function (descriptors) {
            var names = Object.keys(descriptors).sort(),
                total = names.length,
                items = [],
                name, descriptor, i;

            for (i = 0; i < total; i++) {
              name = names[i];
              descriptor = descriptors[name];
              if (descriptor.enumerable) {
                items.push(name);
              }
            }
            var keys = function () { return items; };
            keys.isAutoGenerated = true;
            return keys;
          }
        },
        /**
         * Make a function which can return a representation of the **class**, which
         * can be encoded as JSON.
         *
         * @type {Function}
         */
        makeStaticToJSON: {
          configurable: true,
          value: function (descriptors) {
            var names = Object.keys(descriptors).sort(),
                totalNames = names.length,
                properties = {},
                property, name, descriptor, i,
                keys, totalKeys, key, j;

            for (i = 0; i < totalNames; i++) {
              name = names[i];
              descriptor = descriptors[name];
              if (descriptor.enumerable) {
                keys = Object.keys(descriptor);
                totalKeys = keys.length;
                property = {};
                properties[name] = property;
                for (j = 0; j < totalKeys; j++) {
                  key = keys[j];
                  switch (key) {
                    case 'enumerable':
                    case 'configurable':
                    case 'writable':
                    case 'get':
                    case 'set':
                    case 'value':
                      break;
                    case 'default':
                      if (typeof descriptor.default !== 'function') {
                        property.default = descriptor.default;
                      }
                      break;
                    case 'rules':
                      property.rules = descriptor.rules.map(function (item) {
                        var name;
                        if (Array.isArray(item)) {
                          name = item[0];
                          item = item[1] || {};
                          item.name = name;
                          return item;
                        }
                        else {
                          return item;
                        }
                      });
                      break;
                    default:
                      property[key] = descriptor[key];
                  }
                }
              }
            }
            var toJSON = function () {
              return {
                '@context': this['@context'],
                '@id': this['@id'],
                '@type': this['@type'] || this.name,
                name: this.name,
                properties: properties
              };
            };

            toJSON.isAutoGenerated = true;
            return toJSON;
          }
        }
      });
    }
  }
});

module.exports = Modeling;